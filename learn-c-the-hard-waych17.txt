
   Learn C The Hard Way A Learn Code The Hard Way Book
     * Book
     * Comments
     * Video Courses
     * Related Books

   [next] [prev] [prev-tail] [tail] [up]

Chapter 17
Exercise 16: Structs And Pointers To Them

   In this exercise you'll learn how to make a struct, point a pointer at
   them, and use them to make sense of internal memory structures. I'll
   also apply the knowledge of pointers from the last exercise and get you
   constructing these structures from raw memory using malloc.

   As usual, here's the program we'll talk about, so type it in and make
   it work:
     __________________________________________________________________

   Source 41: ex16.c
   1  #include <stdio.h>
   2  #include <assert.h>
   3  #include <stdlib.h>
   4  #include <string.h>
   5
   6  struct Person {
   7      char *name;
   8      int age;
   9      int height;
   10      int weight;
   11  };
   12
   13  struct Person *Person_create(char *name, int age, int height, int w
   eight)
   14  {
   15      struct Person *who = malloc(sizeof(struct Person));
   16      assert(who != NULL);
   17
   18      who->name = strdup(name);
   19      who->age = age;
   20      who->height = height;
   21      who->weight = weight;
   22
   23      return who;
   24  }
   25
   26  void Person_destroy(struct Person *who)
   27  {
   28      assert(who != NULL);
   29
   30      free(who->name);
   31      free(who);
   32  }
   33
   34  void Person_print(struct Person *who)
   35  {
   36      printf("Name: %s\n", who->name);
   37      printf("\tAge: %d\n", who->age);
   38      printf("\tHeight: %d\n", who->height);
   39      printf("\tWeight: %d\n", who->weight);
   40  }
   41
   42  int main(int argc, char *argv[])
   43  {
   44      // make two people structures
   45      struct Person *joe = Person_create(
   46              "Joe Alex", 32, 64, 140);
   47
   48      struct Person *frank = Person_create(
   49              "Frank Blank", 20, 72, 180);
   50
   51      // print them out and where they are in memory
   52      printf("Joe is at memory location %p:\n", joe);
   53      Person_print(joe);
   54
   55      printf("Frank is at memory location %p:\n", frank);
   56      Person_print(frank);
   57
   58      // make everyone age 20 years and print them again
   59      joe->age += 20;
   60      joe->height -= 2;
   61      joe->weight += 40;
   62      Person_print(joe);
   63
   64      frank->age += 20;
   65      frank->weight += 20;
   66      Person_print(frank);
   67
   68      // destroy them both so we clean up
   69      Person_destroy(joe);
   70      Person_destroy(frank);
   71
   72      return 0;
   73  }
     __________________________________________________________________

   To describe this program, I'm going to use a different approach than
   before. I'm not going to give you a line-by-line breakdown of the
   program, but I'm going to make you write it. I'm going to give you a
   guide through the program based on the parts it contains, and your job
   is to write out what each line does.

   includes
          I include some new header files here to gain access to some new
          functions. What does each give you?

   struct Person
          This is where I'm creating a structure that has 4 elements to
          describe a person. The final result is a new compound type that
          lets me reference these elements all as one, or each piece by
          name. It's similar to a row of a database table or a class in an
          OOP language.

   function Person_create
          I need a way to create these structures so I've made a function
          to do that. Here's the important things this function is doing:

         1. I use malloc for "memory allocate" to ask the OS to give me a
            piece of raw memory.
         2. I pass to malloc the sizeof(struct Person) which calculates
            the total size of the struct, given all the fields inside it.
         3. I use assert to make sure that I have a valid piece of memory
            back from malloc. There's a special constant called NULL that
            you use to mean "unset or invalid pointer". This assert is
            basically checking that malloc didn't return a NULL invalid
            pointer.
         4. I initialize each field of struct Person using the x->y
            syntax, to say what part of the struct I want to set.
         5. I use the strdup function to duplicate the string for the
            name, just to make sure that this structure actually owns it.
            The strdup actually is like malloc and it also copies the
            original string into the memory it creates.

   function Person_destroy
          If I have a create, then I always need a destroy function, and
          this is what destroys Person structs. I again use assert to make
          sure I'm not getting bad input. Then I use the function free to
          return the memory I got with malloc and strdup. If you don't do
          this you get a "memory leak".

   function Person_print
          I then need a way to print out people, which is all this
          function does. It uses the same x->y syntax to get the field
          from the struct to print it.

   function main
          In the main function I use all the previous functions and the
          struct Person to do the following:

         1. Create two people, joe and frank.
         2. Print them out, but notice I'm using the %p format so you can
            see where the program has actually put your struct in memory.
         3. Age both of them by 20 years, with changes to their body too.
         4. Print each one after aging them.
         5. Finally destroy the structures so we can clean up correctly.

   Go through this description carefully, and do the following:
    1. Look up every function and header file you don't know about.
       Remember that you can usually do man 2 function or man 3 function
       and it'll tell you about it. You can also search online for the
       information.
    2. Write a comment above each and every single line saying what the
       line does in English.
    3. Trace through each function call and variable so you know where it
       comes from in the program.
    4. Look up any symbols you don't know as well.

17.1 What You Should See

   After you augment the program with your description comments, make sure
   it really runs and produces this output:
     __________________________________________________________________

   Source 42: ex16 output
   1$ make ex16
   2cc -Wall -g    ex16.c   -o ex16
   3
   4$ ./ex16
   5Joe is at memory location 0xeba010:
   6Name: Joe Alex
   7        Age: 32
   8        Height: 64
   9        Weight: 140
   10Frank is at memory location 0xeba050:
   11Name: Frank Blank
   12        Age: 20
   13        Height: 72
   14        Weight: 180
   15Name: Joe Alex
   16        Age: 52
   17        Height: 62
   18        Weight: 180
   19Name: Frank Blank
   20        Age: 40
   21        Height: 72
   22        Weight: 200
     __________________________________________________________________

17.2 Explaining Structures

   If you've done the work I asked you then structures should be making
   sense, but let me explain them explicitly just to make sure you've
   understood it.

   A structure in C is a collection of other data types (variables) that
   are stored in one block of memory but let you access each variable
   independently by name. They are similar to a record in a database
   table, or a very simplistic class in an object oriented language. We
   can break one down this way:

    1. In the above code, you make a struct that has the fields you'd
       expect for a person: name, age, weight, height.
    2. Each of those fields has a type, like int.
    3. C then packs those together so they can all be contained in one
       single struct.
    4. The struct Person is now a compound data type, which means you can
       now refer to struct Person in the same kinds of expressions you
       would other data types.
    5. This lets you pass the whole cohesive grouping to other functions,
       as you did with Person_print.
    6. You can then access the individual parts of a struct by their names
       using x->y if you're dealing with a pointer.
    7. There's also a way to make a struct that doesn't need a pointer,
       and you use the x.y (period) syntax to work with it. You'll do this
       in the Extra Credit.

   If you didn't have struct you'd need to figure out the size, packing,
   and location of pieces of memory with contents like this. In fact, in
   most early assembler code (and even some now) this is what you do. With
   C you can let C handle the memory structuring of these compound data
   types and then focus on what you do with them.

17.3 How To Break It

   With this program the ways to break it involve how you use the pointers
   and the malloc system:

    1. Try passing NULL to Person_destroy to see what it does. If it
       doesn't abort then you must not have the -g option in your
       Makefile's CFLAGS.
    2. Forget to call Person_destroy at the end, then run it under
       Valgrind to see it report that you forgot to free the memory.
       Figure out the options you need to pass to Valgrind to get it to
       print how you leaked this memory.
    3. Forget to free who->name in Person_destroy and compare the output.
       Again, use the right options to see how Valgrind tells you exactly
       where you messed up.
    4. This time, pass NULL to Person_print and see what Valgrind thinks
       of that.
    5. You should be figuring out that NULL is a quick way to crash your
       program.

17.4 Extra Credit

   In this exercise I want you to attempt something difficult for the
   extra credit: Convert this program to not use pointers and malloc. This
   will be hard, so you'll want to research the following:

    1. How to create a struct on the stack, which means just like you've
       been making any other variable.
    2. How to initialize it using the x.y (period) character instead of
       the x->y syntax.
    3. How to pass a structure to other functions without using a pointer.

   [next] [prev] [prev-tail] [front] [up]
     __________________________________________________________________

   Please enable JavaScript to view the comments powered by Disqus.

Take An Online Video Course

   You can sign up for a video course at:

   http://www.udemy.com/learn-c-the-hard-way/

   This course is currently being built at the same time that the book is
   being built, but if you sign up now then you get early access to both
   the videos and PDF of the book.

Related Books

   You might want to check out these other books in the series:
    1. Learn Ruby The Hard Way
    2. Learn Regex The Hard Way
    3. Learn SQL The Hard Way
    4. Learn C The Hard Way
    5. Learn Python The Hard Way

   I'll be referencing other books shortly.

   Copyright 2011 Zed A. Shaw. All Rights Reserved.
